+++
author = "coucou"
title = "数据结构——基础"
date = "2023-08-01"
description = "数据结构专题之基础"
categories = [
    "数据结构"
]
tags = [
    "数据结构","基础"
]
+++
![](1.png)

[TOC]

# 数据结构

## 1.绪论

### 1. 数据结构的基本概念

- 可以用**抽象数据类型**定义一个完整的数据结构
- 与数据存储结构无关的术语是**栈**，    **循环队列**是用顺序表表示的队列，是一种数据结构
- **数据的逻辑结构独立于其存储结构**
- 在存储数据时，不仅要存储数据元素的值，还要存储**数据元素之间的关系**
- 链式存储设计时，节点内的存储单元地址**一定连续**

不同节点的存储单元地址可以不连续，节点内的存储单元地址必须连续

### 2. 算法和算法评价

- 一个算法应该是**问题求解的步骤**
- 算法原地工作是指**算法所需的辅助空间是常量**

## 2. 线性表

### 1. 线性表的顺序表示

- **存储密度大**是顺序存储结构的优点
- 线性表的顺序存储结构是一种**随机存取的存储结构**
- **线性表的序号是从一开始**

### 2. 线性表的链式表示

- **链式存储结构比顺序存储结构能更方便的表示各种逻辑结构**
- **静态链表需要分配较大的连续空间，插入和删除不需要移动元素**
- 单链表中，增加一个头结点的目的是方便运算的实现
- **单链表中，删除最后一个元素与链表长度有关，其他操作均无关**
- **在尾结点插入和删除数据，带头结点的双循环链表最节省时间**

## 3. 栈，队列和数组

### 1. 栈

- 栈和队列具有相同的**逻辑结构**
- 向一个栈顶指针为top的链栈（不带头结点）中插入一个X节点，则执行**x->next=top;top=x**
- 采用共享栈的好处是**节省存储空间，降低发生上溢的可能**

### 2. 栈和队列的应用

- 栈在**括号应用，表达式求值，递归，进制转换，迷宫求解**等中有应用
- 队列在**层序遍历，bfs，缓冲区，页面替换算法等**中有应用

## 4. 串

- **简单的模式匹配算法时间复杂度为O(mn)，KMP算法的时间复杂度为O(m+n)**
- KMP算法求next数组（重点），视频P36

## 5. 树与二叉树

### 1. 树的基本概念

- 树的路径长度是**从树根到每个节点的路径长度的总和**
- 树中所有节点的度数之和 = 树的所有分支 = 树的节点数目 - 1
- 设树中度为 i 的节点数为  ni

```
节点数 = 各个度的节点数之和 = 1 + 分支数 
n=n0+n1+n2+n3 = 1+n1+2n2+3n3
```

### 2. 二叉树的概念

- 非空二叉树上的叶子节点数等于度为2的节点数加1，即 **n0= n2+1**
- 非空二叉树第k层上至多有 **2^(k-1)** 个节点
- 高度为h的二叉树至多有 **2^h -1** 个节点
- 在含有n个节点的二叉链表中，含有 **n+1** 个空链域 

### 3. 二叉树的遍历与线索二叉树

- 在二叉树中，m是n的祖先，使用**后序遍历**可以找到 m 到 n的路径
- 在二叉树的前序，中序，后序遍历中，所有叶子节点的先后顺序**完全相同**
- 二叉树的先序和后序完全相反，二叉树一定满足**只有一个叶子节点**
- **唯一不能确定一颗二叉树的是 先序遍历和后序遍历**
- 线索二叉树是一种**物理结构**，**tag为0时指向孩子节点，为1时指向线索节点**
- **二叉树在线索化后，仍不能有效求解后序线索二叉树求后序后继**
- **后序线索树**遍历仍需要 栈 的支持

### 3. 树，森林

- 将树转变成二叉树：**左孩子右兄弟**

- 将森林F转换为对应的二叉树T，F中叶节点的个数等于 **T中左孩子指针为空的节点个数**

在一颗二叉树中，如果某个节点的左指针为NULL，就说明这个节点在原来的森林中没有孩子，是叶子节点

### 4. 树与二叉树的应用

- 若没有编码是另一个编码的前缀，则称这样的编码为**前缀编码**
- **在哈夫曼树中只有叶子结点才能作为字符编码**
- 对应一组权值构造出的哈夫曼树不是惟一的
- 哈夫曼树的度只有0和2，没有1
- 并查集的结构是一种 **双亲表示法存储的树**
- **并查集查找操作的时间复杂度为 O(n)**

## 6.图

### 1. 图的基本概念

- 图中有关路径的定义：**由顶点和相邻顶点序偶构成的边所形成的序列**
- **无向图的全部顶点的度的和等于边数的两倍**
- **强连通有向图至少有 n 条边**（构成环）

### 2. 图的存储及基本操作

- 无向图的度为**邻接矩阵中第i行或第i列非零元素之和**
- 一个图的邻接矩阵表示唯一，邻接表表示不唯一
- 在有向图的邻接表存储结构中，顶点 v 在边表中出现的次数为 **顶点v的入度**

解释：这里的边表不包含顶点表（即出度）

- 假设有n个顶点，e条边的有向表用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为**O(n+e)**
- **十字链表是有向图的链式存储结构**
- **邻接多重表是无向图的链式存储结构**

### 3. 图的遍历

- 当各边的权值相等时，广度优先算法可以解决**单源最短路径问题**

- **图的广搜使用队列，深搜使用栈**
- **图的深搜相当于树的 先序遍历**
- 判断有向图中是否存在回路，除了利用拓扑排序外，还可以利用 **深度优先遍历，求关键路径**（求最短路径不行）
- 使用DFS算法递归的遍历一个有环无向图，在退出递归时输出相应顶点，这样得到的顶点序列是**逆拓扑有序**

### 4. 图的应用

- **只要无向连通图中没有权值相同的边，则其最小生成树唯一**、
- **最短路径一定是简单路径**
- 若一个有向图的顶点不能排成一个拓扑序列，则判定该有向图**含义顶点数大于1的强连通分量**
- 若一个有向图具有**有序**的拓扑排序序列，则它的邻接矩阵必定为 **三角**
- 最小生成树代价唯一（形状可能不唯一）

## 7.查找

### 1. 顺序查找和折半查找

- 折半查找过程所对应的判定树是一棵**平衡二叉树**
- 折半查找和二叉排序树的时间性能**有时不相同**

二叉排序树的查找性能和数据的输入顺序有关，最坏情况形成单支树，查找长度为O(n)

- 对表长为n的有序表进行折半查找，判定树的高度为 **log2(n+1)向上取整**

### 2. 树形查找

- 平衡二叉树（AVL）左子树与右子树的高度差称为平衡因子（-1,0,1）
- **节点数最少的平衡二叉树节点数的递推公式（重要）**

```
n1=1  n2=2
n3=n1+n2+1
...
```

- AVL中所有非叶子节点的平衡因子均为1，说明它的叶子节点数最少
- 平衡树的查询效率一般优于红黑树
- 一棵含有n个节点的红黑树的高度至多为 **2log(n+1)**
- **红黑树任意节点的左右子树的高度之差不超过两倍**
- **如果红黑树的所有节点都是黑色的，那么它一定是一棵满二叉树**

### 3. B树，B+树

- B+树不同于B树的特点之一是**能支持顺序查找**
- B树和B+树都可以用于文件索引结构
- B+树更加适用于实际应用中的**操作系统中的文件索引和数据库索引**

### 4. 散列表

- **散列表查找成功的平均查找长度与散列因子有关，与表长无关**
- 若在散列表中删除一个元素，不能简单地将该元素删除（在删除地方做删除标记）
- **采用再散列法处理冲突时不易产生聚集**
- **使用链地址法不会引起聚集现象**

## 8. 排序

### 1. 排序的基本概念

- **排序算法的稳定性是指经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变**
- 拓扑排序不属于内部排序方法
- **使用链表也可以进行排序，只不过有些排序算法不在适用**
- **对同一线性表使用不同的排序方法进行排序，得到的排序结果可能不同**
- 对任意n个关键字排序的比较次数至少为 **log2(n!) 向上取整**

### 2. 插入排序

- 插入排序：直接插入排序，折半插入排序，希尔排序

- 对n个元素的顺序表进行直接插入排序算法，**最坏情况下所需的比较次数是n(n-1)/2 , 最好情况下是（n-1）**
- 与直接插入排序相比，折半插入排序减少了比较元素的次数，元素的移动次数并未改变

### 3.交换排序

- 交换排序：冒泡排序，快速排序
- **快速排序：当每次枢轴都把表等分位长度相近的两个子表时，速度是最快的；当表本身已经有序或者逆序时，速度最慢**
- 递归次数与每次划分后得到的分区的处理顺序无关
- **快速排序的阶段性特点是：第 i 趟完成时，会有i个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，右边的数都比它大**

### 4. 选择排序

- 选择排序：简单选择排序，堆排序
- **简单选择排序的比较次数和移动次数分别为O(n^2)，O(n)**
- **通常，取一大堆数据中的K个最大（最小）元素时，都优先采用堆排序**
- 向具有n个元素的堆中插入一个元素的时间复杂度为 O(logn),删除一个元素的时间复杂度为 O(logn)
- 构建 n 个记录的初始堆，时间复杂度为 O(n) , 进行堆排序，最坏情况下，时间复杂度为 O(nlogn)

### 5. 归并排序和基数排序

- 基数排序不需要进行关键字的比较
- 平均情况下空间复杂度为O(n)的是**归并排序**，最坏情况下空间复杂度为O(n)的是 **归并排序，快速排序**
-  对10TB的数据文件进行排序，应使用的方法是**归并排序**

### 6.各个排序算法比较

| 排序算法名称 | 时间复杂度  | 空间复杂度 | 稳定性 | 适用性             |
| ------------ | ----------- | ---------- | ------ | ------------------ |
| 直接插入排序 | O(n^2)      | O(1)       | 稳定   | 顺序存储和链式存储 |
| 折半插入排序 | O(n^2)      |            | 稳定   | 顺序存储           |
| 希尔排序     | O(n^2)      | O(1)       | 不稳定 | 顺序存储           |
| 冒泡排序     | O(n^2)      | O(1)       | 稳定   | 顺序存储           |
| 快速排序     | O(nlogn)    | O(logn)    | 不稳定 | 顺序存储           |
| 简单选择排序 | O(n^2)      | O(1)       | 不稳定 |                    |
| 堆排序       | O(nlogn)    | O(1)       | 不稳定 |                    |
| 归并排序     | O(nlogn)    | O(n)       | 稳定   |                    |
| 基数排序     | O(d（n+r）) | O(r)       | 稳定   |                    |

- 排序趟数与序列初始状态无关的排序算法是 **直接插入，简单选择，基数排序**
- 每趟排序结束后都至少能够确定一个元素最终位置的方法是**简单选择，快速，堆排序**
- 元素的移动次数与初始排列次序无关的是**基数排序**

### 7. 外部排序

- 在做m路平衡归并排序的过程中，为实现**输入/内部归并/输出的并行处理**，需要设置 **2m个输入缓冲区，2个输出缓冲区**
- 如何判定添加虚段的数目？

设度为0的节点有N0个，度为k的节点有Nk个，则对严格的k叉树有 N0 = (k-1)Nk+1 ，由此得 **NK = （N0-1）/(k-1)**  (Nk必须为整数)

============================================================================================================================================================================================================================================================================================================================================================================

# **数据类型**:

在C语言中，有各种不同的数据类型，以下是一些常见的C数据类型：

1. **基本数据类型**：
   - `char`: 用于存储字符，通常占用1个字节。
   - `int`: 用于存储整数，通常占用4个字节。
   - `float`: 用于存储单精度浮点数，通常占用4个字节。
   - `double`: 用于存储双精度浮点数，通常占用8个字节。

2. **修饰符数据类型**：
   - `signed`: 表示有符号整数。
   - `unsigned`: 表示无符号整数。
   - `short`: 缩短整数的存储范围。
   - `long`: 增加整数的存储范围。
   - `long long`: 提供更大范围的整数存储。

3. **派生数据类型**：
   - `数组`: 用于存储相同类型的多个元素。
   - `指针`: 存储变量的地址。
   - `结构体`: 可以存储不同类型的数据。
   - `共用体`: 允许在相同的内存位置存储不同的数据类型。
   - `枚举`: 用于定义命名整数常量。

4. **自定义数据类型**：
   - `typedef`: 用于为现有数据类型创建新名称。

5. **布尔数据类型**：
   - C语言标准中没有内置的布尔类型，通常使用整数类型（如int）来表示布尔值，0表示false，非零值表示true。

# **数据结构**:

这是关于常见数据结构的简要概述：

1. **数组（Array）**：
   - 线性数据结构，元素类型相同，通过索引访问。
   - 内存中连续存储，支持快速随机访问。

2. **链表（Linked List）**：
   - 由节点组成，每个节点包含数据和指向下一个节点的指针。
   - 可以是单向、双向或循环的，动态分配内存，插入和删除操作高效。

3. **栈（Stack）**：
   - 后进先出（LIFO）的数据结构，仅允许在栈顶进行插入和删除操作。
   - 常用于表达式求值、函数调用等。

4. **队列（Queue）**：
   - 先进先出（FIFO）的数据结构，允许在队尾插入元素，在队头删除元素。
   - 用于模拟排队、任务调度等场景。

5. **树（Tree）**：
   - 非线性数据结构，由节点组成，每个节点可以有零个或多个子节点。
   - 常见类型有二叉树、二叉搜索树、平衡二叉树等。

6. **图（Graph）**：
   - 由节点（顶点）和边组成，用于表示对象之间的关系。
   - 可以是有向的或无向的，常用于网络路由、社交网络分析等。

7. **堆（Heap）**：
   - 一种特殊的树形数据结构，常用于实现优先队列。
   - 分为最大堆和最小堆，支持高效的插入和删除操作。

8. **哈希表（Hash Table）**：
   - 通过哈希函数将键映射到值，实现快速的查找、插入和删除操作。
   - 常用于实现字典、缓存等，具有常数时间复杂度的查找操作。

这些数据结构在计算机科学和软件开发中扮演着重要角色，每种结构都有其独特的特性和适用场景。深入了解这些数据结构将有助于理解和设计高效的算法和程序。

在C语言中，虽然没有内置的高级数据结构（如Python中的列表或字典），但可以通过使用指针和自定义数据结构来实现各种数据结构。以下是在C语言中实现常见数据结构的一些基本概念和示例：

# **数组**：

- 在C语言中，数组是一组相同类型的元素的集合，可以通过下标来访问元素。

- 示例：

  ```c
  int arr[5] = {1, 2, 3, 4, 5};
  ```

# **链表**：

- 链表是由节点组成的数据结构，在C语言中通常使用结构体和指针来表示节点。

- 示例：

  ```c
  struct Node {
      int data;
      struct Node* next;
  };
  
  struct Node* head = NULL; // 头指针初始化为空
  ```

以下是C语言中几种常见链表类型的简单示例代码，包括单链表、双链表和循环链表的基本操作：

### **单链表（Singly Linked List）**：

1. **特点**：
   - 每个节点包含一个数据域和一个指向下一个节点的指针。
   - 最后一个节点的指针指向 NULL，表示链表的结束。
2. **优点**：
   - 简单且易于实现。
   - 插入和删除节点的操作效率高。
3. **缺点**：
   - 无法直接访问前一个节点，需要从头节点开始遍历链表。
   - 只能单向遍历链表。

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

void append(struct Node** head_ref, int new_data) {
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    struct Node* last = *head_ref;
    
    new_node->data = new_data;
    new_node->next = NULL;
    
    if (*head_ref == NULL) {
        *head_ref = new_node;
        return;
    }
    
    while (last->next != NULL) {
        last = last->next;
    }
    
    last->next = new_node;
}

void printList(struct Node* node) {
    while (node != NULL) {
        printf("%d -> ", node->data);
        node = node->next;
    }
    printf("NULL\n");
}

int main() {
    struct Node* head = NULL;
    
    append(&head, 1);
    append(&head, 2);
    append(&head, 3);
    
    printf("Singly Linked List: ");
    printList(head);
    
    return 0;
}
```

### **双链表（Doubly Linked List）**：

1. **特点**：
   - 每个节点包含一个数据域、一个指向下一个节点的指针和一个指向前一个节点的指针。
   - 头节点的前驱指针指向 NULL，尾节点的后继指针指向 NULL。
2. **优点**：
   - 可以双向遍历链表，提供更多操作灵活性。
   - 删除操作相对于单链表更高效，因为可以直接访问前一个节点。
3. **缺点**：
   - 需要额外的指针空间，可能占用更多内存。

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

void append(struct Node** head_ref, int new_data) {
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    struct Node* last = *head_ref;
    
    new_node->data = new_data;
    new_node->next = NULL;
    
    if (*head_ref == NULL) {
        *head_ref = new_node;
        return;
    }
    
    while (last->next != NULL) {
        last = last->next;
    }
    
    last->next = new_node;
    new_node->prev = last;
}

void printList(struct Node* node) {
    while (node != NULL) {
        printf("%d -> ", node->data);
        node = node->next;
    }
    printf("NULL\n");
}

int main() {
    struct Node* head = NULL;
    
    append(&head, 1);
    append(&head, 2);
    append(&head, 3);
    
    printf("Doubly Linked List: ");
    printList(head);
    
    return 0;
}
```

### **循环链表（Circular Linked List）**：

1. **特点**：
   - 最后一个节点的指针指向头节点，形成一个循环。
   - 可以是循环单链表或循环双链表。
2. **优点**：
   - 可以实现循环遍历，适用于需要循环访问的场景。
3. **缺点**：
   - 需要特殊处理循环结束的条件，避免无限循环。

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

void append(struct Node** head_ref, int new_data) {
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    struct Node* last = *head_ref;
    
    new_node->data = new_data;
    new_node->next = *head_ref;
    
    if (*head_ref == NULL) {
        *head_ref = new_node;
        new_node->next = *head_ref;
    } else {
        while (last->next != *head_ref) {
            last = last->next;
        }
        last->next = new_node;
    }
}

void printList(struct Node* head) {
    struct Node* temp = head;
    if (head != NULL) {
        do {
            printf("%d -> ", temp->data);
            temp = temp->next;
        } while (temp != head);
    }
    printf("NULL\n");
}

int main() {
    struct Node* head = NULL;
    
    append(&head, 1);
    append(&head, 2);
    append(&head, 3);
    
    printf("Circular Linked List: ");
    printList(head);
    
    return 0;
}
```

# **栈**：

- 栈可以使用数组或链表实现，在C语言中通常使用数组来模拟栈。

- 示例：

  ```c
  #define MAX_SIZE 100
  int stack[MAX_SIZE];
  int top = -1; // 栈顶指针初始化为-1
  
  // 压栈操作
  void push(int value) {
      if (top < MAX_SIZE - 1) {
          stack[++top] = value;
      }
  }
  
  // 弹栈操作
  int pop() {
      if (top >= 0) {
          return stack[top--];
      }
      return -1; // 表示栈为空
  }
  ```

# **队列**：

- 队列可以使用数组或链表实现，在C语言中通常使用数组来模拟队列。

- 示例：

  ```c
  #define MAX_SIZE 100
  int queue[MAX_SIZE];
  int front = 0, rear = -1; // 队头指针和队尾指针
  
  // 入队操作
  void enqueue(int value) {
      if (rear < MAX_SIZE - 1) {
          queue[++rear] = value;
      }
  }
  
  // 出队操作
  int dequeue() {
      if (front <= rear) {
          return queue[front++];
      }
      return -1; // 表示队列为空
  }
  ```

# **树与二叉树**:

在C语言中，树和二叉树是常见的数据结构，以下是它们的简单示例代码：

###  **树（Tree）**：

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

int main() {
    struct Node* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    
    // 手动构建一个简单的树结构
    /*
            1
           / \
          2   3
    */
    
    return 0;
}
```

### **二叉树（Binary Tree）**：

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

int main() {
    struct Node* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);
    
    // 手动构建一个简单的二叉树结构
    /*
            1
           / \
          2   3
         / \
        4   5
    */
    
    return 0;
}
```

